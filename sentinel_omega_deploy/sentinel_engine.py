import cv2
import numpy as np
from ultralytics import YOLO
import supervision as sv
from deepface import DeepFace
import easyocr
from fpdf import FPDF
from datetime import datetime
import os

class SentinelReport(FPDF):
    def header(self):
        self.set_font('Arial', 'B', 15)
        self.cell(80)
        self.cell(30, 10, 'SENTINEL OMEGA // INTELLIGENCE REPORT', 0, 0, 'C')
        self.ln(20)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.cell(0, 10, f'Generated by Neural Core | Page {self.page_no()}', 0, 0, 'C')

class SentinelEngine:
    def __init__(self, model_size='m'):
        print(f"⏳ Loading YOLOv8{model_size} Weights...")
        self.model = YOLO(f'yolov8{model_size}.pt')
        
        # --- INTELLIGENCE MODULES (Phase 2) ---
        print("⏳ Loading OCR Engine...")
        self.reader = easyocr.Reader(['en'], gpu=True)
        
        # --- TRACKERS & ANNOTATORS (Phase 1 + 2) ---
        self.tracker = sv.ByteTrack()
        
        self.box_annotator = sv.BoxAnnotator(thickness=2)
        self.label_annotator = sv.LabelAnnotator(text_scale=0.5, text_padding=5)
        
        # Advanced Visual Layers
        self.trace_annotator = sv.TraceAnnotator(thickness=2, trace_length=30)
        self.heatmap_annotator = sv.HeatMapAnnotator()
        
        # Ensure DB exists for Face ID
        os.makedirs("face_db", exist_ok=True)
        print("✅ Sentinel Omega Engine Online.")

    def reset_trackers(self):
        """Resets tracking history for new video sessions"""
        self.tracker = sv.ByteTrack()
        self.heatmap_annotator = sv.HeatMapAnnotator()
        self.trace_annotator = sv.TraceAnnotator(thickness=2, trace_length=30)

    def register_face(self, image_bytes, name):
        """Saves face to DB for DeepFace"""
        try:
            nparr = np.frombuffer(image_bytes, np.uint8)
            img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            save_path = f"face_db/{name}.jpg"
            cv2.imwrite(save_path, img)
            
            # Clear cache to force reload
            if os.path.exists("face_db/representations_vgg_face.pkl"):
                os.remove("face_db/representations_vgg_face.pkl")
            return True
        except Exception as e:
            print(f"Registration Error: {e}")
            return False

    def process_frame_detailed(self, frame, conf=0.3, active_modules=[], enable_heatmap=False, enable_trace=True):
        # 1. Standard Inference
        results = self.model(frame, conf=conf, verbose=False)[0]
        detections = sv.Detections.from_ultralytics(results)
        
        # 2. Tracking (Assign IDs)
        detections = self.tracker.update_with_detections(detections)
        
        # 3. Intelligence Layer (Analyze Detections)
        labels = []
        known_faces = []

        # [Biometrics] Scan for faces once per frame if enabled
        if 'face_id' in active_modules:
            try:
                dfs = DeepFace.find(img_path=frame, db_path="face_db", 
                                  model_name="VGG-Face", enforce_detection=False, silent=True)
                if len(dfs) > 0:
                    for df in dfs:
                        if not df.empty:
                            full_path = df.iloc[0]['identity']
                            name = os.path.basename(full_path).split('.')[0]
                            x = int(df.iloc[0]['source_x'])
                            y = int(df.iloc[0]['source_y'])
                            known_faces.append((name, x, y))
            except: pass

        # Loop through each detection to generate Smart Labels
        for xyxy, mask, confidence, class_id, tracker_id, data in detections:
            base_label = self.model.model.names[class_id]
            final_label = base_label
            
            # [Threat Detection]
            if base_label in ['knife', 'scissors', 'baseball bat', 'gun']:
                final_label = f"⚠️ WEAPON ({base_label})"
            
            # [Biometrics] Match Face
            if 'face_id' in active_modules and base_label == 'person':
                x1, y1, x2, y2 = map(int, xyxy)
                for name, fx, fy in known_faces:
                    # Check if face center is inside person box
                    if x1 < fx < x2 and y1 < fy < y2:
                        final_label = f"✅ {name.upper()} (AUTH)"
                        break
                if "AUTH" not in final_label:
                    final_label = "❌ UNKNOWN"

            # [ANPR] License Plate Reading
            if 'anpr' in active_modules and base_label in ['car', 'truck']:
                x1, y1, x2, y2 = map(int, xyxy)
                if (x2-x1) > 100: # Only check large/close cars
                    try:
                        car_crop = frame[y1:y2, x1:x2]
                        ocr = self.reader.readtext(car_crop, detail=0)
                        if ocr:
                            plate_text = max(ocr, key=len)
                            if len(plate_text) > 4:
                                final_label = f"PLATE: {plate_text.upper()}"
                    except: pass

            labels.append(f"#{tracker_id} {final_label}")

        # 4. Visual Layer (Draw Annotations)
        annotated_frame = frame.copy()
        
        if enable_trace:
            annotated_frame = self.trace_annotator.annotate(
                scene=annotated_frame, detections=detections
            )

        if enable_heatmap:
            annotated_frame = self.heatmap_annotator.annotate(
                scene=annotated_frame, detections=detections
            )

        annotated_frame = self.box_annotator.annotate(scene=annotated_frame, detections=detections)
        annotated_frame = self.label_annotator.annotate(
            scene=annotated_frame, detections=detections, labels=labels
        )
        
        # 5. Extract Stats
        stats = {}
        for l in labels:
            # Clean label for clean reporting (Remove ID and emojis)
            parts = l.split(' ')
            if len(parts) > 1:
                clean_name = " ".join(parts[1:]) # Remove #ID
                stats[clean_name] = stats.get(clean_name, 0) + 1
            
        return annotated_frame, stats, detections

    def generate_image_report(self, stats, image_path):
        pdf = SentinelReport()
        pdf.add_page()
        self._write_report_body(pdf, stats, "STATIC THREAT ANALYSIS")
        pdf.image(image_path, x=10, y=100, w=190)
        output_path = "sentinel_image_report.pdf"
        pdf.output(output_path)
        return output_path

    def generate_video_report(self, unique_stats):
        pdf = SentinelReport()
        pdf.add_page()
        self._write_report_body(pdf, unique_stats, "VIDEO SURVEILLANCE LOG")
        output_path = "sentinel_video_report.pdf"
        pdf.output(output_path)
        return output_path

    def _write_report_body(self, pdf, stats, title_text):
        pdf.set_font("Arial", size=12)
        pdf.cell(200, 10, txt=f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", ln=1)
        pdf.cell(200, 10, txt=f"Mission Type: {title_text}", ln=1)
        pdf.ln(10)
        
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(200, 10, txt="DETECTED ENTITIES:", ln=1)
        pdf.set_font("Courier", size=12)
        
        if not stats:
            pdf.cell(200, 10, txt="No targets detected.", ln=1)
        else:
            for obj, count in stats.items():
                pdf.cell(200, 10, txt=f" > {obj}: {count}", ln=1)
        pdf.ln(10)
